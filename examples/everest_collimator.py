# copyright ############################### #
# This file is part of the Xcoll package.   #
# Copyright (c) CERN, 2024.                 #
# ######################################### #

import numpy as np
from pathlib import Path
import matplotlib.pyplot as plt

import xobjects as xo
import xtrack as xt
import xpart as xp
import xcoll as xc



# --------------------------------------------------------
# -------------------- Initialisation --------------------
# --------------------------------------------------------
# Make a context and get a buffer
context = xo.ContextCpu()         # For CPU
# context = xo.ContextCupy()      # For CUDA GPUs
# context = xo.ContextPyopencl()  # For OpenCL GPUs

beam = 1
path_in = Path(__file__).parent


# Load from json
line = xt.Line.from_json(path_in / 'machines' / f'lhc_run3_b{beam}_no_aper.json')


# Install primary collimators
TCPH = xc.EverestCollimator(length=0.6, gap=5, material=xc.materials.MolybdenumGraphite, emittance=3.5e-6)
TCPV = xc.EverestCollimator(length=0.6, gap=5, material=xc.materials.MolybdenumGraphite, angle=90, emittance=3.5e-6)
TCPS = xc.EverestCollimator(length=0.6, gap=5, material=xc.materials.Carbon, angle=127.5, emittance=3.5e-6)
line.collimators.install(['tcp.c6l7.b1', 'tcp.d6l7.b1', 'tcp.b6l7.b1'], [TCPH, TCPV, TCPS], need_apertures=False)


# Aperture model check
print('\nAperture model check after introducing collimators:')
df_with_coll = line.check_aperture()
assert not np.any(df_with_coll.has_aperture_problem)


# Build the tracker
line.build_tracker()


# Assign the optics to deduce the gap settings
line.collimators.assign_optics()


# --------------------------------------------------------
# ------------------ Tracking (test 1) -------------------
# --------------------------------------------------------
#
# As a first test, we just track 5 turns.
# We expect to see the transversal profile generated by
# the three primaries opened at 5 sigma.


# Create initial particles
n_sigmas = 10
n_part = 50000
x_norm = np.random.uniform(-n_sigmas, n_sigmas, n_part)
y_norm = np.random.uniform(-n_sigmas, n_sigmas, n_part)
part = line.build_particles(x_norm=x_norm, y_norm=y_norm,
                            nemitt_x=3.5e-6, nemitt_y=3.5e-6,
                            at_element='tcp.d6l7.b1'
                           )

# Track
print("Tracking first test.. ")
line.scattering.enable()
line.track(part, num_turns=1)
line.scattering.disable()

# Sort the particles by their ID
part.sort(interleave_lost_particles=True)

# Plot the surviving particles as green
plt.figure(1,figsize=(12,12))
plt.plot(x_norm, y_norm, '.', color='red')
plt.plot(x_norm[part.state>0], y_norm[part.state>0], '.', color='green')
plt.axis('equal')
plt.axis([n_sigmas, -n_sigmas, -n_sigmas, n_sigmas])
plt.show()


# --------------------------------------------------------
# ------------------ Tracking (test 2) -------------------
# --------------------------------------------------------
#
# As a second test, we remove all collimator openings
# (which is done by setting them to 1 meter) except the
# horizontal primary. We give the latter an asymmetric
# opening, and an angle of 15 degrees.
# This is done to check our coordinate implementations.
# We only track one turn, because otherwise betatron
# oscillations would make the cut profile symmetric anyway.

line['tcp.c6l7.b1'].angle = 15
line.collimators.open()
line['tcp.c6l7.b1'].gap = [4, -7]

# Create initial particles
part = line.build_particles(x_norm=x_norm, y_norm=y_norm,
                            nemitt_x=3.5e-6, nemitt_y=3.5e-6,
                            at_element='tcp.c6l7.b1'
                           )

# Track
print("Tracking second test.. ")
line.scattering.enable()
line.track(part, num_turns=1)
line.scattering.disable()

# Sort the particles by their ID
part.sort(interleave_lost_particles=True)

# Plot the surviving particles as green
plt.figure(1,figsize=(12,12))
plt.plot(x_norm, y_norm, '.', color='red', alpha=0.4)
plt.plot(x_norm[part.state>0], y_norm[part.state>0], '.', color='green')
plt.axis('equal')
plt.axis([n_sigmas, -n_sigmas, -n_sigmas, n_sigmas])
plt.show()

